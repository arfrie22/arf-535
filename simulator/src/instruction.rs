use crate::enums::{Condition, FPRegister, Register, Timer};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Instruction {
    Invalid(u32),
    Trap,
    PushIntegerRegister { rx: Register },
    PushFloatingPointRegister { fx: FPRegister },
    PopIntegerRegister { rx: Register },
    PopFloatingPointRegister { fx: FPRegister },
    SwapRegister { rx: Register, fy: FPRegister },
    Stall { rx: Register },
    RegisterJump { condition: Condition, rx: Register },
    IndirectJump { condition: Condition, rx: Register, i: u32, s: u32 },
    IndirectwithRegisterOffsetJump { condition: Condition, rx: Register, ro: Register, s: u32 },
    RelativeJump { condition: Condition, rx: Register },
    ImmediateJump { condition: Condition, label: u32 },
    ImmediateRelativeJump { condition: Condition, offset: u32 },
    RegisterJumpwithLink { condition: Condition, rx: Register },
    IndirectJumpwithLink { condition: Condition, rx: Register, i: u32, s: u32 },
    IndirectwithRegisterOffsetJumpwithLink { condition: Condition, rx: Register, ro: Register, s: u32 },
    RelativeJumpwithLink { condition: Condition, rx: Register },
    ImmediateJumpwithLink { condition: Condition, label: u32 },
    ImmediateRelativeJumpwithLink { condition: Condition, offset: u32 },
    IntegerLoadLow { rx: Register, value: u32 },
    IntegerLoadHigh { rx: Register, value: u32 },
    SwapIntegerRegisters { rx: Register, ry: Register },
    CopyIntegerRegister { rx: Register, ry: Register },
    LoadIntegerRegisterIndirect { rx: Register, ry: Register, i: u32, s: u32 },
    LoadIntegerRegisterIndirectwithRegisterOffset { rx: Register, ry: Register, ro: Register, s: u32 },
    LoadIntegerRegisterIndirectProgram { rx: Register, ry: Register, i: u32, s: u32 },
    LoadIntegerRegisterIndirectwithRegisterOffsetProgram { rx: Register, ry: Register, ro: Register, s: u32 },
    StoreIntegerRegisterIndirect { rx: Register, ry: Register, i: u32, s: u32 },
    StoreIntegerRegisterIndirectwithRegisterOffsetIndirect { rx: Register, ry: Register, ro: Register, s: u32 },
    StoreIntegerRegisterIndirectProgram { rx: Register, ry: Register, i: u32, s: u32 },
    StoreIntegerRegisterIndirectwithRegisterOffsetProgram { rx: Register, ry: Register, ro: Register, s: u32 },
    IntegerLoadData { rx: Register, label: u32 },
    IntegerLoadProgram { rx: Register, label: u32 },
    IntegerStoreData { rx: Register, label: u32 },
    IntegerStoreProgram { rx: Register, label: u32 },
    UnsignedZeroExtend { rx: Register, ry: Register, count: u32 },
    SignExtend { rx: Register, ry: Register, count: u32 },
    FloatingPointLoadLow { fx: FPRegister, value: u32 },
    FloatingPointLoadHigh { fx: FPRegister, value: u32 },
    SwapFloatingPointRegisters { fx: FPRegister, fy: FPRegister },
    CopyFloatingPointRegister { fx: FPRegister, fy: FPRegister },
    LoadFloatingPointRegisterIndirect { fx: FPRegister, ry: Register, i: u32, s: u32 },
    LoadFloatingPointRegisterIndirectwithRegisterOffset { fx: FPRegister, ry: Register, ro: Register, s: u32 },
    StoreFloatingPointRegisterIndirect { rx: Register, fy: FPRegister, i: u32, s: u32 },
    StoreFloatingPointRegisterIndirectwithRegisterOffset { rx: Register, fy: FPRegister, ro: Register, s: u32 },
    FloatingPointLoadData { rx: Register, label: u32 },
    FloatingPointStoreData { rx: Register, label: u32 },
    IntegerCompare { rx: Register, ry: Register },
    IntegerCompareSingleAgainstZero { rx: Register },
    AddUnsignedInteger { rx: Register, ry: Register, rz: Register },
    SubtractUnsignedInteger { rx: Register, ry: Register, rz: Register },
    MultiplyUnsignedInteger { rx: Register, ry: Register, rz: Register },
    DivideUnsignedInteger { rx: Register, ry: Register, rz: Register },
    ModuloUnsignedInteger { rx: Register, ry: Register, rz: Register },
    AddSignedInteger { rx: Register, ry: Register, rz: Register },
    SubtractSignedInteger { rx: Register, ry: Register, rz: Register },
    MultiplySignedInteger { rx: Register, ry: Register, rz: Register },
    DivideSignedInteger { rx: Register, ry: Register, rz: Register },
    ModuloSignedInteger { rx: Register, ry: Register, rz: Register },
    BitwiseAND { rx: Register, ry: Register, rz: Register },
    BitwiseOR { rx: Register, ry: Register, rz: Register },
    BitwiseNOT { rx: Register, ry: Register, rz: Register },
    BitwiseXOR { rx: Register, ry: Register, rz: Register },
    LogicalShiftLeft { rx: Register, ry: Register, value: u32 },
    LogicalShiftRight { rx: Register, ry: Register, value: u32 },
    ArithmeticShiftLeft { rx: Register, ry: Register, value: u32 },
    ArithmeticShiftRight { rx: Register, ry: Register, value: u32 },
    RotateRight { rx: Register, ry: Register, value: u32 },
    LogicalShiftLeftRegister { rx: Register, ry: Register, rz: Register },
    LogicalShiftRightRegister { rx: Register, ry: Register, rz: Register },
    ArithmeticShiftLeftRegister { rx: Register, ry: Register, rz: Register },
    ArithmeticShiftRightRegister { rx: Register, ry: Register, rz: Register },
    RotateRightRegister { rx: Register, ry: Register, rz: Register },
    MapUnsignedToSigned { rx: Register, ry: Register },
    MapSignedToUnsigned { rx: Register, ry: Register },
    FloatingPointCompare { fx: FPRegister, fy: FPRegister },
    FloatingPointCompareSingleAgainstZero { fx: FPRegister },
    AddFloatingPoint { fx: FPRegister, fy: FPRegister, fz: FPRegister },
    SubtractFloatingPoint { fx: FPRegister, fy: FPRegister, fz: FPRegister },
    MultiplyFloatingPoint { fx: FPRegister, fy: FPRegister, fz: FPRegister },
    DivideFloatingPoint { fx: FPRegister, fy: FPRegister, fz: FPRegister },
    CasttoFloat { fx: FPRegister, ry: Register },
    CastfromFloat { rx: Register, fy: FPRegister },
    SetTimer { tx: Timer, ry: Register },
    GetCurrentTimer { tx: Timer, ry: Register },
    CheckTimer { tx: Timer },
    ClearTimer { tx: Timer },
}

impl From<u32> for Instruction {
    fn from(value: u32) -> Self {
        match value >> 24 {
            0x00 => Self::Trap,
            0x01 => Self::PushIntegerRegister { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap() },
            0x02 => Self::PushFloatingPointRegister { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap() },
            0x03 => Self::PopIntegerRegister { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap() },
            0x04 => Self::PopFloatingPointRegister { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap() },
            0x05 => Self::SwapRegister { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), fy: FPRegister::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0x06 => Self::Stall { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap() },
            0x20 => Self::RegisterJump { condition: Condition::try_from(((value as usize) >> 19) & 0x1f).unwrap(), rx: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0x21 => Self::IndirectJump { condition: Condition::try_from(((value as usize) >> 19) & 0x1f).unwrap(), rx: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), i: (value >> 9) & 0x1f, s: (value >> 5) & 0xf },
            0x22 => Self::IndirectwithRegisterOffsetJump { condition: Condition::try_from(((value as usize) >> 19) & 0x1f).unwrap(), rx: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), ro: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap(), s: (value >> 5) & 0xf },
            0x23 => Self::RelativeJump { condition: Condition::try_from(((value as usize) >> 19) & 0x1f).unwrap(), rx: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0x24 => Self::ImmediateJump { condition: Condition::try_from(((value as usize) >> 19) & 0x1f).unwrap(), label: (value >> 3) & 0xffff },
            0x25 => Self::ImmediateRelativeJump { condition: Condition::try_from(((value as usize) >> 19) & 0x1f).unwrap(), offset: (value >> 3) & 0xffff },
            0x26 => Self::RegisterJumpwithLink { condition: Condition::try_from(((value as usize) >> 19) & 0x1f).unwrap(), rx: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0x27 => Self::IndirectJumpwithLink { condition: Condition::try_from(((value as usize) >> 19) & 0x1f).unwrap(), rx: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), i: (value >> 9) & 0x1f, s: (value >> 5) & 0xf },
            0x28 => Self::IndirectwithRegisterOffsetJumpwithLink { condition: Condition::try_from(((value as usize) >> 19) & 0x1f).unwrap(), rx: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), ro: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap(), s: (value >> 5) & 0xf },
            0x29 => Self::RelativeJumpwithLink { condition: Condition::try_from(((value as usize) >> 19) & 0x1f).unwrap(), rx: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0x2a => Self::ImmediateJumpwithLink { condition: Condition::try_from(((value as usize) >> 19) & 0x1f).unwrap(), label: (value >> 3) & 0xffff },
            0x2b => Self::ImmediateRelativeJumpwithLink { condition: Condition::try_from(((value as usize) >> 19) & 0x1f).unwrap(), offset: (value >> 3) & 0xffff },
            0x40 => Self::IntegerLoadLow { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), value: (value >> 3) & 0xffff },
            0x41 => Self::IntegerLoadHigh { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), value: (value >> 3) & 0xffff },
            0x42 => Self::SwapIntegerRegisters { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0x43 => Self::CopyIntegerRegister { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0x44 => Self::LoadIntegerRegisterIndirect { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), i: (value >> 9) & 0x1f, s: (value >> 5) & 0xf },
            0x45 => Self::LoadIntegerRegisterIndirectwithRegisterOffset { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), ro: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap(), s: (value >> 5) & 0xf },
            0x46 => Self::LoadIntegerRegisterIndirectProgram { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), i: (value >> 9) & 0x1f, s: (value >> 5) & 0xf },
            0x47 => Self::LoadIntegerRegisterIndirectwithRegisterOffsetProgram { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), ro: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap(), s: (value >> 5) & 0xf },
            0x48 => Self::StoreIntegerRegisterIndirect { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), i: (value >> 9) & 0x1f, s: (value >> 5) & 0xf },
            0x49 => Self::StoreIntegerRegisterIndirectwithRegisterOffsetIndirect { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), ro: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap(), s: (value >> 5) & 0xf },
            0x4a => Self::StoreIntegerRegisterIndirectProgram { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), i: (value >> 9) & 0x1f, s: (value >> 5) & 0xf },
            0x4b => Self::StoreIntegerRegisterIndirectwithRegisterOffsetProgram { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), ro: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap(), s: (value >> 5) & 0xf },
            0x4c => Self::IntegerLoadData { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), label: (value >> 3) & 0xffff },
            0x4d => Self::IntegerLoadProgram { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), label: (value >> 3) & 0xffff },
            0x4e => Self::IntegerStoreData { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), label: (value >> 3) & 0xffff },
            0x4f => Self::IntegerStoreProgram { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), label: (value >> 3) & 0xffff },
            0x50 => Self::UnsignedZeroExtend { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), count: (value >> 9) & 0x1f },
            0x51 => Self::SignExtend { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), count: (value >> 9) & 0x1f },
            0x60 => Self::FloatingPointLoadLow { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap(), value: (value >> 3) & 0xffff },
            0x61 => Self::FloatingPointLoadHigh { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap(), value: (value >> 3) & 0xffff },
            0x62 => Self::SwapFloatingPointRegisters { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap(), fy: FPRegister::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0x63 => Self::CopyFloatingPointRegister { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap(), fy: FPRegister::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0x64 => Self::LoadFloatingPointRegisterIndirect { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), i: (value >> 9) & 0x1f, s: (value >> 5) & 0xf },
            0x65 => Self::LoadFloatingPointRegisterIndirectwithRegisterOffset { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), ro: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap(), s: (value >> 5) & 0xf },
            0x66 => Self::StoreFloatingPointRegisterIndirect { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), fy: FPRegister::try_from(((value as usize) >> 14) & 0x1f).unwrap(), i: (value >> 9) & 0x1f, s: (value >> 5) & 0xf },
            0x67 => Self::StoreFloatingPointRegisterIndirectwithRegisterOffset { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), fy: FPRegister::try_from(((value as usize) >> 14) & 0x1f).unwrap(), ro: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap(), s: (value >> 5) & 0xf },
            0x68 => Self::FloatingPointLoadData { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), label: (value >> 3) & 0xffff },
            0x69 => Self::FloatingPointStoreData { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), label: (value >> 3) & 0xffff },
            0x80 => Self::IntegerCompare { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0x81 => Self::IntegerCompareSingleAgainstZero { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap() },
            0x82 => Self::AddUnsignedInteger { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x83 => Self::SubtractUnsignedInteger { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x84 => Self::MultiplyUnsignedInteger { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x85 => Self::DivideUnsignedInteger { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x86 => Self::ModuloUnsignedInteger { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x87 => Self::AddSignedInteger { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x88 => Self::SubtractSignedInteger { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x89 => Self::MultiplySignedInteger { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x8a => Self::DivideSignedInteger { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x8b => Self::ModuloSignedInteger { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x8c => Self::BitwiseAND { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x8d => Self::BitwiseOR { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x8e => Self::BitwiseNOT { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x8f => Self::BitwiseXOR { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x90 => Self::LogicalShiftLeft { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), value: (value >> 9) & 0x1f },
            0x91 => Self::LogicalShiftRight { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), value: (value >> 9) & 0x1f },
            0x92 => Self::ArithmeticShiftLeft { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), value: (value >> 9) & 0x1f },
            0x93 => Self::ArithmeticShiftRight { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), value: (value >> 9) & 0x1f },
            0x94 => Self::RotateRight { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), value: (value >> 9) & 0x1f },
            0x95 => Self::LogicalShiftLeftRegister { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x96 => Self::LogicalShiftRightRegister { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x97 => Self::ArithmeticShiftLeftRegister { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x98 => Self::ArithmeticShiftRightRegister { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x99 => Self::RotateRightRegister { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x9a => Self::MapUnsignedToSigned { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0x9b => Self::MapSignedToUnsigned { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0xa0 => Self::FloatingPointCompare { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap(), fy: FPRegister::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0xa1 => Self::FloatingPointCompareSingleAgainstZero { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap() },
            0xa2 => Self::AddFloatingPoint { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap(), fy: FPRegister::try_from(((value as usize) >> 14) & 0x1f).unwrap(), fz: FPRegister::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0xa3 => Self::SubtractFloatingPoint { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap(), fy: FPRegister::try_from(((value as usize) >> 14) & 0x1f).unwrap(), fz: FPRegister::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0xa4 => Self::MultiplyFloatingPoint { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap(), fy: FPRegister::try_from(((value as usize) >> 14) & 0x1f).unwrap(), fz: FPRegister::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0xa5 => Self::DivideFloatingPoint { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap(), fy: FPRegister::try_from(((value as usize) >> 14) & 0x1f).unwrap(), fz: FPRegister::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0xa6 => Self::CasttoFloat { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0xa7 => Self::CastfromFloat { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), fy: FPRegister::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0xc0 => Self::SetTimer { tx: Timer::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0xc1 => Self::GetCurrentTimer { tx: Timer::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0xc2 => Self::CheckTimer { tx: Timer::try_from(((value as usize) >> 19) & 0x1f).unwrap() },
            0xc3 => Self::ClearTimer { tx: Timer::try_from(((value as usize) >> 19) & 0x1f).unwrap() },
            _ => Self::Invalid(value),
        }
    }
}

