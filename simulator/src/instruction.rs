use crate::enums::{Condition, FPRegister, Register, Timer};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Instruction {
    Invalid(u32),
    Trap,
    PushIntegerRegister { rx: Register },
    PushFloatingPointRegister { fx: FPRegister },
    PopIntegerRegister { rx: Register },
    PopFloatingPointRegister { fx: FPRegister },
    SwapRegister { rx: Register, fy: FPRegister },
    Stall { rx: Register },
    RegisterJump { condition: Condition, rx: Register },
    IndirectJump { condition: Condition, rx: Register, i: u32, s: u32 },
    IndirectwithRegisterOffsetJump { condition: Condition, rx: Register, ro: Register, s: u32 },
    RelativeJump { condition: Condition, rx: Register },
    ImmediateJump { condition: Condition, label: u32 },
    ImmediateRelativeJump { condition: Condition, offset: u32 },
    RegisterJumpwithLink { condition: Condition, rx: Register },
    IndirectJumpwithLink { condition: Condition, rx: Register, i: u32, s: u32 },
    IndirectwithRegisterOffsetJumpwithLink { condition: Condition, rx: Register, ro: Register, s: u32 },
    RelativeJumpwithLink { condition: Condition, rx: Register },
    ImmediateJumpwithLink { condition: Condition, label: u32 },
    ImmediateRelativeJumpwithLink { condition: Condition, offset: u32 },
    IntegerLoadLow { rx: Register, value: u32 },
    IntegerLoadHigh { rx: Register, value: u32 },
    SwapIntegerRegisters { rx: Register, ry: Register },
    CopyIntegerRegister { rx: Register, ry: Register },
    LoadIntegerRegisterIndirect { rx: Register, ry: Register, i: u32, s: u32 },
    LoadIntegerRegisterIndirectwithRegisterOffset { rx: Register, ry: Register, ro: Register, s: u32 },
    LoadIntegerRegisterIndirectProgram { rx: Register, ry: Register, i: u32, s: u32 },
    LoadIntegerRegisterIndirectwithRegisterOffsetProgram { rx: Register, ry: Register, ro: Register, s: u32 },
    StoreIntegerRegisterIndirect { rx: Register, ry: Register, i: u32, s: u32 },
    StoreIntegerRegisterIndirectwithRegisterOffsetIndirect { rx: Register, ry: Register, ro: Register, s: u32 },
    StoreIntegerRegisterIndirectProgram { rx: Register, ry: Register, i: u32, s: u32 },
    StoreIntegerRegisterIndirectwithRegisterOffsetProgram { rx: Register, ry: Register, ro: Register, s: u32 },
    IntegerLoadData { rx: Register, label: u32 },
    IntegerLoadProgram { rx: Register, label: u32 },
    IntegerStoreData { rx: Register, label: u32 },
    IntegerStoreProgram { rx: Register, label: u32 },
    UnsignedZeroExtend { rx: Register, ry: Register, count: u32 },
    SignExtend { rx: Register, ry: Register, count: u32 },
    FloatingPointLoadLow { fx: FPRegister, value: u32 },
    FloatingPointLoadHigh { fx: FPRegister, value: u32 },
    SwapFloatingPointRegisters { fx: FPRegister, fy: FPRegister },
    CopyFloatingPointRegister { fx: FPRegister, fy: FPRegister },
    LoadFloatingPointRegisterIndirect { fx: FPRegister, ry: Register, i: u32, s: u32 },
    LoadFloatingPointRegisterIndirectwithRegisterOffset { fx: FPRegister, ry: Register, ro: Register, s: u32 },
    StoreFloatingPointRegisterIndirect { rx: Register, fy: FPRegister, i: u32, s: u32 },
    StoreFloatingPointRegisterIndirectwithRegisterOffset { rx: Register, fy: FPRegister, ro: Register, s: u32 },
    FloatingPointLoadData { rx: Register, label: u32 },
    FloatingPointStoreData { rx: Register, label: u32 },
    IntegerCompare { rx: Register, ry: Register },
    IntegerCompareSingleAgainstZero { rx: Register },
    AddUnsignedInteger { rx: Register, ry: Register, rz: Register },
    SubtractUnsignedInteger { rx: Register, ry: Register, rz: Register },
    MultiplyUnsignedInteger { rx: Register, ry: Register, rz: Register },
    DivideUnsignedInteger { rx: Register, ry: Register, rz: Register },
    ModuloUnsignedInteger { rx: Register, ry: Register, rz: Register },
    AddSignedInteger { rx: Register, ry: Register, rz: Register },
    SubtractSignedInteger { rx: Register, ry: Register, rz: Register },
    MultiplySignedInteger { rx: Register, ry: Register, rz: Register },
    DivideSignedInteger { rx: Register, ry: Register, rz: Register },
    ModuloSignedInteger { rx: Register, ry: Register, rz: Register },
    BitwiseAND { rx: Register, ry: Register, rz: Register },
    BitwiseOR { rx: Register, ry: Register, rz: Register },
    BitwiseNOT { rx: Register, ry: Register, rz: Register },
    BitwiseXOR { rx: Register, ry: Register, rz: Register },
    LogicalShiftLeft { rx: Register, ry: Register, value: u32 },
    LogicalShiftRight { rx: Register, ry: Register, value: u32 },
    ArithmeticShiftLeft { rx: Register, ry: Register, value: u32 },
    ArithmeticShiftRight { rx: Register, ry: Register, value: u32 },
    RotateRight { rx: Register, ry: Register, value: u32 },
    LogicalShiftLeftRegister { rx: Register, ry: Register, rz: Register },
    LogicalShiftRightRegister { rx: Register, ry: Register, rz: Register },
    ArithmeticShiftLeftRegister { rx: Register, ry: Register, rz: Register },
    ArithmeticShiftRightRegister { rx: Register, ry: Register, rz: Register },
    RotateRightRegister { rx: Register, ry: Register, rz: Register },
    MapUnsignedToSigned { rx: Register, ry: Register },
    MapSignedToUnsigned { rx: Register, ry: Register },
    FloatingPointCompare { fx: FPRegister, fy: FPRegister },
    FloatingPointCompareSingleAgainstZero { fx: FPRegister },
    AddFloatingPoint { fx: FPRegister, fy: FPRegister, fz: FPRegister },
    SubtractFloatingPoint { fx: FPRegister, fy: FPRegister, fz: FPRegister },
    MultiplyFloatingPoint { fx: FPRegister, fy: FPRegister, fz: FPRegister },
    DivideFloatingPoint { fx: FPRegister, fy: FPRegister, fz: FPRegister },
    CasttoFloat { fx: FPRegister, ry: Register },
    CastfromFloat { rx: Register, fy: FPRegister },
    SetTimer { tx: Timer, ry: Register },
    GetCurrentTimer { tx: Timer, ry: Register },
    CheckTimer { tx: Timer },
    ClearTimer { tx: Timer },
}

impl From<u32> for Instruction {
    fn from(value: u32) -> Self {
        match value >> 24 {
            0x00 => Self::Trap,
            0x01 => Self::PushIntegerRegister { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap() },
            0x02 => Self::PushFloatingPointRegister { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap() },
            0x03 => Self::PopIntegerRegister { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap() },
            0x04 => Self::PopFloatingPointRegister { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap() },
            0x05 => Self::SwapRegister { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), fy: FPRegister::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0x06 => Self::Stall { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap() },
            0x20 => Self::RegisterJump { condition: Condition::try_from(((value as usize) >> 19) & 0x1f).unwrap(), rx: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0x21 => Self::IndirectJump { condition: Condition::try_from(((value as usize) >> 19) & 0x1f).unwrap(), rx: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), i: (value >> 9) & 0x1f, s: (value >> 5) & 0xf },
            0x22 => Self::IndirectwithRegisterOffsetJump { condition: Condition::try_from(((value as usize) >> 19) & 0x1f).unwrap(), rx: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), ro: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap(), s: (value >> 5) & 0xf },
            0x23 => Self::RelativeJump { condition: Condition::try_from(((value as usize) >> 19) & 0x1f).unwrap(), rx: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0x24 => Self::ImmediateJump { condition: Condition::try_from(((value as usize) >> 19) & 0x1f).unwrap(), label: (value >> 3) & 0xffff },
            0x25 => Self::ImmediateRelativeJump { condition: Condition::try_from(((value as usize) >> 19) & 0x1f).unwrap(), offset: (value >> 3) & 0xffff },
            0x26 => Self::RegisterJumpwithLink { condition: Condition::try_from(((value as usize) >> 19) & 0x1f).unwrap(), rx: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0x27 => Self::IndirectJumpwithLink { condition: Condition::try_from(((value as usize) >> 19) & 0x1f).unwrap(), rx: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), i: (value >> 9) & 0x1f, s: (value >> 5) & 0xf },
            0x28 => Self::IndirectwithRegisterOffsetJumpwithLink { condition: Condition::try_from(((value as usize) >> 19) & 0x1f).unwrap(), rx: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), ro: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap(), s: (value >> 5) & 0xf },
            0x29 => Self::RelativeJumpwithLink { condition: Condition::try_from(((value as usize) >> 19) & 0x1f).unwrap(), rx: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0x2a => Self::ImmediateJumpwithLink { condition: Condition::try_from(((value as usize) >> 19) & 0x1f).unwrap(), label: (value >> 3) & 0xffff },
            0x2b => Self::ImmediateRelativeJumpwithLink { condition: Condition::try_from(((value as usize) >> 19) & 0x1f).unwrap(), offset: (value >> 3) & 0xffff },
            0x40 => Self::IntegerLoadLow { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), value: (value >> 3) & 0xffff },
            0x41 => Self::IntegerLoadHigh { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), value: (value >> 3) & 0xffff },
            0x42 => Self::SwapIntegerRegisters { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0x43 => Self::CopyIntegerRegister { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0x44 => Self::LoadIntegerRegisterIndirect { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), i: (value >> 9) & 0x1f, s: (value >> 5) & 0xf },
            0x45 => Self::LoadIntegerRegisterIndirectwithRegisterOffset { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), ro: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap(), s: (value >> 5) & 0xf },
            0x46 => Self::LoadIntegerRegisterIndirectProgram { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), i: (value >> 9) & 0x1f, s: (value >> 5) & 0xf },
            0x47 => Self::LoadIntegerRegisterIndirectwithRegisterOffsetProgram { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), ro: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap(), s: (value >> 5) & 0xf },
            0x48 => Self::StoreIntegerRegisterIndirect { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), i: (value >> 9) & 0x1f, s: (value >> 5) & 0xf },
            0x49 => Self::StoreIntegerRegisterIndirectwithRegisterOffsetIndirect { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), ro: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap(), s: (value >> 5) & 0xf },
            0x4a => Self::StoreIntegerRegisterIndirectProgram { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), i: (value >> 9) & 0x1f, s: (value >> 5) & 0xf },
            0x4b => Self::StoreIntegerRegisterIndirectwithRegisterOffsetProgram { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), ro: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap(), s: (value >> 5) & 0xf },
            0x4c => Self::IntegerLoadData { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), label: (value >> 3) & 0xffff },
            0x4d => Self::IntegerLoadProgram { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), label: (value >> 3) & 0xffff },
            0x4e => Self::IntegerStoreData { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), label: (value >> 3) & 0xffff },
            0x4f => Self::IntegerStoreProgram { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), label: (value >> 3) & 0xffff },
            0x50 => Self::UnsignedZeroExtend { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), count: (value >> 9) & 0x1f },
            0x51 => Self::SignExtend { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), count: (value >> 9) & 0x1f },
            0x60 => Self::FloatingPointLoadLow { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap(), value: (value >> 3) & 0xffff },
            0x61 => Self::FloatingPointLoadHigh { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap(), value: (value >> 3) & 0xffff },
            0x62 => Self::SwapFloatingPointRegisters { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap(), fy: FPRegister::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0x63 => Self::CopyFloatingPointRegister { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap(), fy: FPRegister::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0x64 => Self::LoadFloatingPointRegisterIndirect { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), i: (value >> 9) & 0x1f, s: (value >> 5) & 0xf },
            0x65 => Self::LoadFloatingPointRegisterIndirectwithRegisterOffset { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), ro: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap(), s: (value >> 5) & 0xf },
            0x66 => Self::StoreFloatingPointRegisterIndirect { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), fy: FPRegister::try_from(((value as usize) >> 14) & 0x1f).unwrap(), i: (value >> 9) & 0x1f, s: (value >> 5) & 0xf },
            0x67 => Self::StoreFloatingPointRegisterIndirectwithRegisterOffset { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), fy: FPRegister::try_from(((value as usize) >> 14) & 0x1f).unwrap(), ro: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap(), s: (value >> 5) & 0xf },
            0x68 => Self::FloatingPointLoadData { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), label: (value >> 3) & 0xffff },
            0x69 => Self::FloatingPointStoreData { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), label: (value >> 3) & 0xffff },
            0x80 => Self::IntegerCompare { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0x81 => Self::IntegerCompareSingleAgainstZero { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap() },
            0x82 => Self::AddUnsignedInteger { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x83 => Self::SubtractUnsignedInteger { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x84 => Self::MultiplyUnsignedInteger { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x85 => Self::DivideUnsignedInteger { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x86 => Self::ModuloUnsignedInteger { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x87 => Self::AddSignedInteger { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x88 => Self::SubtractSignedInteger { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x89 => Self::MultiplySignedInteger { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x8a => Self::DivideSignedInteger { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x8b => Self::ModuloSignedInteger { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x8c => Self::BitwiseAND { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x8d => Self::BitwiseOR { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x8e => Self::BitwiseNOT { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x8f => Self::BitwiseXOR { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x90 => Self::LogicalShiftLeft { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), value: (value >> 9) & 0x1f },
            0x91 => Self::LogicalShiftRight { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), value: (value >> 9) & 0x1f },
            0x92 => Self::ArithmeticShiftLeft { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), value: (value >> 9) & 0x1f },
            0x93 => Self::ArithmeticShiftRight { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), value: (value >> 9) & 0x1f },
            0x94 => Self::RotateRight { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), value: (value >> 9) & 0x1f },
            0x95 => Self::LogicalShiftLeftRegister { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x96 => Self::LogicalShiftRightRegister { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x97 => Self::ArithmeticShiftLeftRegister { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x98 => Self::ArithmeticShiftRightRegister { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x99 => Self::RotateRightRegister { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap(), rz: Register::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0x9a => Self::MapUnsignedToSigned { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0x9b => Self::MapSignedToUnsigned { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0xa0 => Self::FloatingPointCompare { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap(), fy: FPRegister::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0xa1 => Self::FloatingPointCompareSingleAgainstZero { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap() },
            0xa2 => Self::AddFloatingPoint { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap(), fy: FPRegister::try_from(((value as usize) >> 14) & 0x1f).unwrap(), fz: FPRegister::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0xa3 => Self::SubtractFloatingPoint { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap(), fy: FPRegister::try_from(((value as usize) >> 14) & 0x1f).unwrap(), fz: FPRegister::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0xa4 => Self::MultiplyFloatingPoint { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap(), fy: FPRegister::try_from(((value as usize) >> 14) & 0x1f).unwrap(), fz: FPRegister::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0xa5 => Self::DivideFloatingPoint { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap(), fy: FPRegister::try_from(((value as usize) >> 14) & 0x1f).unwrap(), fz: FPRegister::try_from(((value as usize) >> 9) & 0x1f).unwrap() },
            0xa6 => Self::CasttoFloat { fx: FPRegister::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0xa7 => Self::CastfromFloat { rx: Register::try_from(((value as usize) >> 19) & 0x1f).unwrap(), fy: FPRegister::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0xc0 => Self::SetTimer { tx: Timer::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0xc1 => Self::GetCurrentTimer { tx: Timer::try_from(((value as usize) >> 19) & 0x1f).unwrap(), ry: Register::try_from(((value as usize) >> 14) & 0x1f).unwrap() },
            0xc2 => Self::CheckTimer { tx: Timer::try_from(((value as usize) >> 19) & 0x1f).unwrap() },
            0xc3 => Self::ClearTimer { tx: Timer::try_from(((value as usize) >> 19) & 0x1f).unwrap() },
            _ => Self::Invalid(value),
        }
    }
}

impl Into<u32> for Instruction {
    fn into(self) -> u32 {
        match self {
            Self::Trap => 0x00 << 24,
            Self::PushIntegerRegister { rx } => (0x01 << 24)| ((rx as u32) << 19),
            Self::PushFloatingPointRegister { fx } => (0x02 << 24)| ((fx as u32) << 19),
            Self::PopIntegerRegister { rx } => (0x03 << 24)| ((rx as u32) << 19),
            Self::PopFloatingPointRegister { fx } => (0x04 << 24)| ((fx as u32) << 19),
            Self::SwapRegister { rx, fy } => (0x05 << 24)| ((rx as u32) << 19)| ((fy as u32) << 14),
            Self::Stall { rx } => (0x06 << 24)| ((rx as u32) << 19),
            Self::RegisterJump { condition, rx } => (0x20 << 24)| ((condition as u32) << 19)| ((rx as u32) << 14),
            Self::IndirectJump { condition, rx, i, s } => (0x21 << 24)| ((condition as u32) << 19)| ((rx as u32) << 14)| (i << 9)| (s << 5),
            Self::IndirectwithRegisterOffsetJump { condition, rx, ro, s } => (0x22 << 24)| ((condition as u32) << 19)| ((rx as u32) << 14)| ((ro as u32) << 9)| (s << 5),
            Self::RelativeJump { condition, rx } => (0x23 << 24)| ((condition as u32) << 19)| ((rx as u32) << 14),
            Self::ImmediateJump { condition, label } => (0x24 << 24)| ((condition as u32) << 19)| (label << 3),
            Self::ImmediateRelativeJump { condition, offset } => (0x25 << 24)| ((condition as u32) << 19)| (offset << 3),
            Self::RegisterJumpwithLink { condition, rx } => (0x26 << 24)| ((condition as u32) << 19)| ((rx as u32) << 14),
            Self::IndirectJumpwithLink { condition, rx, i, s } => (0x27 << 24)| ((condition as u32) << 19)| ((rx as u32) << 14)| (i << 9)| (s << 5),
            Self::IndirectwithRegisterOffsetJumpwithLink { condition, rx, ro, s } => (0x28 << 24)| ((condition as u32) << 19)| ((rx as u32) << 14)| ((ro as u32) << 9)| (s << 5),
            Self::RelativeJumpwithLink { condition, rx } => (0x29 << 24)| ((condition as u32) << 19)| ((rx as u32) << 14),
            Self::ImmediateJumpwithLink { condition, label } => (0x2a << 24)| ((condition as u32) << 19)| (label << 3),
            Self::ImmediateRelativeJumpwithLink { condition, offset } => (0x2b << 24)| ((condition as u32) << 19)| (offset << 3),
            Self::IntegerLoadLow { rx, value } => (0x40 << 24)| ((rx as u32) << 19)| (value << 3),
            Self::IntegerLoadHigh { rx, value } => (0x41 << 24)| ((rx as u32) << 19)| (value << 3),
            Self::SwapIntegerRegisters { rx, ry } => (0x42 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14),
            Self::CopyIntegerRegister { rx, ry } => (0x43 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14),
            Self::LoadIntegerRegisterIndirect { rx, ry, i, s } => (0x44 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| (i << 9)| (s << 5),
            Self::LoadIntegerRegisterIndirectwithRegisterOffset { rx, ry, ro, s } => (0x45 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| ((ro as u32) << 9)| (s << 5),
            Self::LoadIntegerRegisterIndirectProgram { rx, ry, i, s } => (0x46 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| (i << 9)| (s << 5),
            Self::LoadIntegerRegisterIndirectwithRegisterOffsetProgram { rx, ry, ro, s } => (0x47 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| ((ro as u32) << 9)| (s << 5),
            Self::StoreIntegerRegisterIndirect { rx, ry, i, s } => (0x48 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| (i << 9)| (s << 5),
            Self::StoreIntegerRegisterIndirectwithRegisterOffsetIndirect { rx, ry, ro, s } => (0x49 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| ((ro as u32) << 9)| (s << 5),
            Self::StoreIntegerRegisterIndirectProgram { rx, ry, i, s } => (0x4a << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| (i << 9)| (s << 5),
            Self::StoreIntegerRegisterIndirectwithRegisterOffsetProgram { rx, ry, ro, s } => (0x4b << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| ((ro as u32) << 9)| (s << 5),
            Self::IntegerLoadData { rx, label } => (0x4c << 24)| ((rx as u32) << 19)| (label << 3),
            Self::IntegerLoadProgram { rx, label } => (0x4d << 24)| ((rx as u32) << 19)| (label << 3),
            Self::IntegerStoreData { rx, label } => (0x4e << 24)| ((rx as u32) << 19)| (label << 3),
            Self::IntegerStoreProgram { rx, label } => (0x4f << 24)| ((rx as u32) << 19)| (label << 3),
            Self::UnsignedZeroExtend { rx, ry, count } => (0x50 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| (count << 9),
            Self::SignExtend { rx, ry, count } => (0x51 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| (count << 9),
            Self::FloatingPointLoadLow { fx, value } => (0x60 << 24)| ((fx as u32) << 19)| (value << 3),
            Self::FloatingPointLoadHigh { fx, value } => (0x61 << 24)| ((fx as u32) << 19)| (value << 3),
            Self::SwapFloatingPointRegisters { fx, fy } => (0x62 << 24)| ((fx as u32) << 19)| ((fy as u32) << 14),
            Self::CopyFloatingPointRegister { fx, fy } => (0x63 << 24)| ((fx as u32) << 19)| ((fy as u32) << 14),
            Self::LoadFloatingPointRegisterIndirect { fx, ry, i, s } => (0x64 << 24)| ((fx as u32) << 19)| ((ry as u32) << 14)| (i << 9)| (s << 5),
            Self::LoadFloatingPointRegisterIndirectwithRegisterOffset { fx, ry, ro, s } => (0x65 << 24)| ((fx as u32) << 19)| ((ry as u32) << 14)| ((ro as u32) << 9)| (s << 5),
            Self::StoreFloatingPointRegisterIndirect { rx, fy, i, s } => (0x66 << 24)| ((rx as u32) << 19)| ((fy as u32) << 14)| (i << 9)| (s << 5),
            Self::StoreFloatingPointRegisterIndirectwithRegisterOffset { rx, fy, ro, s } => (0x67 << 24)| ((rx as u32) << 19)| ((fy as u32) << 14)| ((ro as u32) << 9)| (s << 5),
            Self::FloatingPointLoadData { rx, label } => (0x68 << 24)| ((rx as u32) << 19)| (label << 3),
            Self::FloatingPointStoreData { rx, label } => (0x69 << 24)| ((rx as u32) << 19)| (label << 3),
            Self::IntegerCompare { rx, ry } => (0x80 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14),
            Self::IntegerCompareSingleAgainstZero { rx } => (0x81 << 24)| ((rx as u32) << 19),
            Self::AddUnsignedInteger { rx, ry, rz } => (0x82 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| ((rz as u32) << 9),
            Self::SubtractUnsignedInteger { rx, ry, rz } => (0x83 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| ((rz as u32) << 9),
            Self::MultiplyUnsignedInteger { rx, ry, rz } => (0x84 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| ((rz as u32) << 9),
            Self::DivideUnsignedInteger { rx, ry, rz } => (0x85 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| ((rz as u32) << 9),
            Self::ModuloUnsignedInteger { rx, ry, rz } => (0x86 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| ((rz as u32) << 9),
            Self::AddSignedInteger { rx, ry, rz } => (0x87 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| ((rz as u32) << 9),
            Self::SubtractSignedInteger { rx, ry, rz } => (0x88 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| ((rz as u32) << 9),
            Self::MultiplySignedInteger { rx, ry, rz } => (0x89 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| ((rz as u32) << 9),
            Self::DivideSignedInteger { rx, ry, rz } => (0x8a << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| ((rz as u32) << 9),
            Self::ModuloSignedInteger { rx, ry, rz } => (0x8b << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| ((rz as u32) << 9),
            Self::BitwiseAND { rx, ry, rz } => (0x8c << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| ((rz as u32) << 9),
            Self::BitwiseOR { rx, ry, rz } => (0x8d << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| ((rz as u32) << 9),
            Self::BitwiseNOT { rx, ry, rz } => (0x8e << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| ((rz as u32) << 9),
            Self::BitwiseXOR { rx, ry, rz } => (0x8f << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| ((rz as u32) << 9),
            Self::LogicalShiftLeft { rx, ry, value } => (0x90 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| (value << 9),
            Self::LogicalShiftRight { rx, ry, value } => (0x91 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| (value << 9),
            Self::ArithmeticShiftLeft { rx, ry, value } => (0x92 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| (value << 9),
            Self::ArithmeticShiftRight { rx, ry, value } => (0x93 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| (value << 9),
            Self::RotateRight { rx, ry, value } => (0x94 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| (value << 9),
            Self::LogicalShiftLeftRegister { rx, ry, rz } => (0x95 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| ((rz as u32) << 9),
            Self::LogicalShiftRightRegister { rx, ry, rz } => (0x96 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| ((rz as u32) << 9),
            Self::ArithmeticShiftLeftRegister { rx, ry, rz } => (0x97 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| ((rz as u32) << 9),
            Self::ArithmeticShiftRightRegister { rx, ry, rz } => (0x98 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| ((rz as u32) << 9),
            Self::RotateRightRegister { rx, ry, rz } => (0x99 << 24)| ((rx as u32) << 19)| ((ry as u32) << 14)| ((rz as u32) << 9),
            Self::MapUnsignedToSigned { rx, ry } => (0x9a << 24)| ((rx as u32) << 19)| ((ry as u32) << 14),
            Self::MapSignedToUnsigned { rx, ry } => (0x9b << 24)| ((rx as u32) << 19)| ((ry as u32) << 14),
            Self::FloatingPointCompare { fx, fy } => (0xa0 << 24)| ((fx as u32) << 19)| ((fy as u32) << 14),
            Self::FloatingPointCompareSingleAgainstZero { fx } => (0xa1 << 24)| ((fx as u32) << 19),
            Self::AddFloatingPoint { fx, fy, fz } => (0xa2 << 24)| ((fx as u32) << 19)| ((fy as u32) << 14)| ((fz as u32) << 9),
            Self::SubtractFloatingPoint { fx, fy, fz } => (0xa3 << 24)| ((fx as u32) << 19)| ((fy as u32) << 14)| ((fz as u32) << 9),
            Self::MultiplyFloatingPoint { fx, fy, fz } => (0xa4 << 24)| ((fx as u32) << 19)| ((fy as u32) << 14)| ((fz as u32) << 9),
            Self::DivideFloatingPoint { fx, fy, fz } => (0xa5 << 24)| ((fx as u32) << 19)| ((fy as u32) << 14)| ((fz as u32) << 9),
            Self::CasttoFloat { fx, ry } => (0xa6 << 24)| ((fx as u32) << 19)| ((ry as u32) << 14),
            Self::CastfromFloat { rx, fy } => (0xa7 << 24)| ((rx as u32) << 19)| ((fy as u32) << 14),
            Self::SetTimer { tx, ry } => (0xc0 << 24)| ((tx as u32) << 19)| ((ry as u32) << 14),
            Self::GetCurrentTimer { tx, ry } => (0xc1 << 24)| ((tx as u32) << 19)| ((ry as u32) << 14),
            Self::CheckTimer { tx } => (0xc2 << 24)| ((tx as u32) << 19),
            Self::ClearTimer { tx } => (0xc3 << 24)| ((tx as u32) << 19),
            Self::Invalid(value) => value,
        }
    }
}

